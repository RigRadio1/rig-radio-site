<!-- DASH_PROOF 9b1a -->
<!doctype html>
<html lang="en">
<head>
  <!-- Canonical host guard: force www -->
  <script>
  (function(){
    var want = 'www.rig-radio.ai';
    if (location.hostname !== want) {
      var target = 'https://' + want + location.pathname + location.search + location.hash;
      location.replace(target);
    }
  })();
  </script>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Rig-Radio • Dashboard</title>
  <link rel="stylesheet" href="/rr.css"/>
  <style>
    body.rr-bg { min-height: 100vh; }
    .wrap { max-width: 1100px; margin: 10px auto 22px; padding: 0 16px; }
    header { display:flex; align-items:center; justify-content:space-between; margin-bottom:16px; }
    .brand { font-weight:800; font-size:24px; letter-spacing:.5px; user-select:none; }
    /* ensure "Outlaw Airwaves" is NOT a link */
    .brand .tag { font-weight:600; opacity:.85; font-size:14px; margin-left:8px; }

    .grid { display:grid; grid-template-columns: 1fr 1fr; gap:16px; }
    @media (max-width: 900px){ .grid { grid-template-columns: 1fr; } }

    .card { background: rgba(15,18,24,.7); border:1px solid rgba(255,255,255,.08);
            border-radius:16px; padding:16px; box-shadow: 0 6px 24px rgba(0,0,0,.35); }

    /* uploads list (left) */
    #tracks-list .track-row { display:flex; gap:12px; align-items:center; padding:8px 0; border-bottom:1px solid rgba(255,255,255,.06); }
    #tracks-list .track-row:last-child { border-bottom:0; }
    #tracks-list .cover { width:56px; height:56px; background:#111 center/cover no-repeat; border-radius:10px; }
    .track-main { display:flex; flex-direction:column; min-width:0; }
    .track-title { font-weight:700; overflow:hidden; white-space:nowrap; text-overflow:ellipsis; }
    .track-sub { opacity:.8; font-size:12px; overflow:hidden; white-space:nowrap; text-overflow:ellipsis; }

    /* playlist (right) */
    #my-playlist { margin-top:8px; }
    #nowPlaying { margin: 10px auto 22px; font-weight:600; }
    .controls { display:flex; gap:8px; margin: 10px auto 22px; }
    .controls button { border-radius:10px; padding:8px 12px; border:1px solid rgba(255,255,255,.12); background:rgba(255,255,255,.04); cursor:pointer; }
    .controls button:hover { background:rgba(255,255,255,.08); }

    .progress-wrap { margin-top:8px; }
    #playlistList { display:flex; flex-direction:column; gap:8px; margin-top:12px; }
    .track-item { display:flex; gap:10px; padding:10px; border:1px solid rgba(255,255,255,.08); border-radius:12px; cursor:pointer; align-items:center; }
    .track-item .thumb { width:44px; height:44px; border-radius:8px; background:#111 center/cover no-repeat; }
    .track-item .meta { display:flex; flex-direction:column; min-width:0; }
    .track-item .t { font-weight:700; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
    .track-item .a { opacity:.85; font-size:12px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
    .track-item.active { outline:2px solid #ff2b2b; box-shadow: 0 0 16px rgba(255,43,43,.25); }

    .muted { opacity:.8; }
/* --- Player control buttons --- */
.controls button {
  color: #fff !important;
  font-weight: 700;
  margin-right: 6px;           /* space between buttons */
  padding: 4px 10px;
  background: transparent;
  border: 1px solid rgba(255,255,255,0.15);
  border-radius: 6px;
  text-shadow: 0 1px 2px rgba(0,0,0,.6);
  cursor: pointer;
  transition: all 0.2s ease;
}
.controls button:hover {
  border-color: #ff2b2b;
  color: #ff2b2b !important;
  text-shadow: 0 0 6px #ff2b2b;
}
<style>
  /* existing CSS … */
/* --- Custom seek bar style (cross-browser red fill) --- */
#seek{
  -webkit-appearance:none;
  appearance:none;
  width:100%;
  height:6px;
  border-radius:3px;
  outline:none;
  cursor:pointer;
  /* layered background: red fill width = --val, gray remainder */
  background:
    linear-gradient(#ff2b2b, #ff2b2b) 0 / var(--val, 0%) 100% no-repeat,
    #222;
}

/* Chrome/Edge (WebKit) */
#seek::-webkit-slider-runnable-track{
  height:6px;
  border-radius:3px;
  background: transparent; /* let #seek background show */
}
#seek::-webkit-slider-thumb{
  -webkit-appearance:none;
  width:12px;height:12px;border-radius:50%;
  background:#ff2b2b;border:none;
  box-shadow:0 0 6px #ff2b2b;
  margin-top:-3px; /* center on 6px track */
}

/* Firefox */
#seek::-moz-range-track{
  height:6px;border-radius:3px;background:#222;
}
#seek::-moz-range-progress{
  height:6px;border-radius:3px;background:#ff2b2b;
}
#seek::-moz-range-thumb{
  width:12px;height:12px;border-radius:50%;
  background:#ff2b2b;border:none;
  box-shadow:0 0 6px #ff2b2b;
}
/* Header action buttons */
.actions .btn {
  display:inline-block;
  color:#fff;
  font-weight:700;
  padding:8px 12px;
  margin-left:8px;
  border:1px solid rgba(255,255,255,.15);
  border-radius:10px;
  background:rgba(255,255,255,.04);
  text-decoration:none;
  cursor:pointer;
  transition:all .2s ease;
}
.actions .btn:hover {
  border-color:#ff2b2b;
  color:#ff2b2b;
  text-shadow:0 0 6px #ff2b2b;
}
/* Dashboard banner */
/* Welcome message */
.welcome {
  text-align:center;
  font-size:1.4rem;
  font-weight:700;
  margin:10px 0 20px;
  color:#fff;
  text-shadow:0 0 6px #ff2b2b;
}
/* Action button row under banner/welcome */
.dash-actions{
  margin: 8px auto 18px;
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  justify-content: center;
}
.dash-actions .btn{
  display:inline-block;
  padding:10px 14px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,.14);
  background:rgba(255,255,255,.05);
  color:#fff; text-decoration:none; font-weight:800;
  letter-spacing:.3px;
  transition:all .2s ease;
}
.dash-actions .btn:hover{
  border-color:#ff2b2b;
  color:#ff2b2b;
  text-shadow:0 0 6px #ff2b2b;
}
.dash-actions .btn.primary{
  border-color:#ff2b2b;
  box-shadow:0 0 12px rgba(255,43,43,.35);
}
.dash-actions .btn.disabled{
  opacity:.45;
  pointer-events:none;
  filter: grayscale(60%);
}
/* Logout button aligned with actions */
.logout-wrap{
  text-align: center;
  margin-top: 10px;
}
.logout-wrap .logout{
  background: rgba(255,255,255,.05);
  border:1px solid rgba(255,255,255,.14);
  border-radius:12px;
  padding:8px 14px;
  color:#fff;
  font-weight:700;
  cursor:pointer;
  transition:all .2s ease;
}
.logout-wrap .logout:hover{
  border-color:#ff2b2b;
  color:#ff2b2b;
  text-shadow:0 0 6px #ff2b2b;
}
/* Logout button aligned under actions */
.logout-wrap{
  text-align: center;
  margin-top: 12px;
}
.logout-wrap .logout{
  background: rgba(255,255,255,.05);
  border:1px solid rgba(255,255,255,.14);
  border-radius:12px;
  padding:8px 14px;
  color:#fff;
  font-weight:700;
  cursor:pointer;
  transition:all .2s ease;
}
.logout-wrap .logout:hover{
  border-color:#ff2b2b;
  color:#ff2b2b;
  text-shadow:0 0 6px #ff2b2b;
}


/* --- Your Uploads: grid card layout --- */
#tracks-list{
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
  gap: 12px;
  align-items: stretch;
}

/* turn each row into a card */
#tracks-list .track-row{
  display: grid;
  grid-template-columns: 56px 1fr;
  gap: 10px;
  align-items: center;
  padding: 10px;
  border: 1px solid rgba(255,255,255,.08);
  background: rgba(255,255,255,.04);
  border-radius: 12px;
  box-shadow: 0 6px 18px rgba(0,0,0,.25);
}

#tracks-list .cover{
  width: 56px; height: 56px; border-radius: 10px;
  background: #111 center/cover no-repeat;
}

#tracks-list .track-main{
  min-width: 0; display: flex; flex-direction: column;
}

#tracks-list .track-title{
  font-weight: 800; overflow: hidden; white-space: nowrap; text-overflow: ellipsis;
}
#tracks-list .track-sub{
  opacity: .8; font-size: 12px; overflow: hidden; white-space: nowrap; text-overflow: ellipsis;
}



  </style>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body class="rr-bg dashboard-page dashboard-page">
<div id="bg"></div>

<div id="welcomeUser" class="welcome"></div>
<!-- Action button row -->
<nav class="dash-actions">
  <a class="btn primary" href="/submit.html">Submit Song</a>
  <a class="btn" href="/library.html">Library</a>
  <span class="btn disabled" title="Coming soon">My Profile</span>
  <span class="btn disabled" title="Coming soon">Videos</span>
  <span class="btn disabled" title="Coming soon">News</span>
  <span class="btn disabled" title="Coming soon">Memberships</span>
  <a class="btn logout" href="javascript:void(0)" onclick="logout()">Log out</a>
</nav>







<div class="logout-wrap">
</div>




  <div class="wrap">
    <div class="hero-banner">
      <img src="/banner.png" alt="Rig-Radio Banner">
    </div>
        <header>
      <div class="brand">
        Rig-Radio <span class="tag">Outlaw Airwaves</span>
      </div>


    </header>

    <div class="grid">
      <!-- LEFT: Your uploads (reference list) -->
      <section class="card">
        <h2>Your Uploads</h2>
        <div id="tracks-list" class="uploads-scroll"><div class="muted">Loading…</div></div>
      </section>

      <!-- RIGHT: Playlist (from Library localStorage or fallback) -->
      <section class="card" id="my-playlist">
        <h2>My Playlist</h2>
        <div id="newTrackToast" class="new-track-toast" style="display:none;"><span class="msg">New track uploaded</span><button class="dismiss" aria-label="Dismiss">✕</button></div>

        <div id="nowPlaying" class="muted">Loading…</div>
    <div class="player-console">

        <div class="controls">
          <button id="prevBtn">⏮ Prev</button>
          <button id="playPauseBtn">▶ Play</button>
          <button id="nextBtn">⏭ Next</button>
        <button id="shuffleBtn" class="toggle" title="Shuffle">Shuffle</button>
        </div>

        <!-- Single, global audio element -->
<audio id="audio" preload="none" style="display:none" oncontextmenu="return false"></audio>



        <!-- Progress / seek -->
        <div id="progressBar" class="progress-wrap">
          <div class="time-row" style="display:flex;justify-content:space-between;font-size:12px;opacity:.85">
            <span id="curTime">0:00</span>
            <span id="durTime">0:00</span>
          </div>
          <input id="seek" type="range" min="0" max="1000" value="0" step="1" style="width:100%">
  <div class="volume-wrap" style="display:flex;align-items:center;gap:10px;margin-top:10px">
    <span class="small-label" style="min-width:48px">Volume</span>
    <input id="volume" type="range" min="0" max="1" step="0.01" value="1" style="flex:1">
  </div>
    </div>
        </div>

        <div class="track-list playlist-scroll" id="playlistList"></div>
    <!-- BEGIN: shortcut-info (FIXES 7) -->
    <div class="shortcut-info" id="shortcutInfoBox">
      <div class="si-title">Keyboard Shortcuts</div>
      <div class="si-line">Space &middot; &larr;/&rarr; &plusmn;5s &middot; &uarr;/&darr; Vol &plusmn;5% &middot; S Shuffle</div>
    </div>
    <!-- END: shortcut-info (FIXES 7) -->
</section>
    </div>
  </div>

  <script>
    /* ---------- Supabase bootstrap ---------- */
    const supabase = window.supabase.createClient(
      'https://tpzpeoqdpfwqumlsyhpx.supabase.co',
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRwenBlb3FkcGZ3cXVtbHN5aHB4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTcwMDM5NTEsImV4cCI6MjA3MjU3OTk1MX0.nP8W_G_N9GKucj6tlzyvSAOjhiqTBD-F564i0gNhp8E'
    );

    /* ---------- Helpers for Storage signing ---------- */
    function extractKeyFromPublicUrl(url){
      // Try to find ".../object/.../tracks/<key>"
      try{
        if (!url) return null;
        const u = new URL(url, window.location.origin);
        const m1 = u.pathname.match(/tracks\/(.+)$/);
        if (m1 && m1[1]) return decodeURIComponent(m1[1]);
      }catch{}
      return null;
    }

    async function signTracksKey(key, seconds = 3600){
      try{
        if (!key) return null;
        const { data, error } = await supabase.storage.from('tracks').createSignedUrl(key, seconds);
        if (error) return null;
        return data.signedUrl;
      }catch{ return null; }
    }

    async function getSignedCover(row){
      if (row.cover_path && typeof row.cover_path === 'string') {
        const s = await signTracksKey(row.cover_path); if (s) return s;
      }
      if (row.cover_url && typeof row.cover_url === 'string') {
        const k = extractKeyFromPublicUrl(row.cover_url); if (k){ const s = await signTracksKey(k); if (s) return s; }
      }
      if (row.artwork_url && typeof row.artwork_url === 'string') {
        const k = extractKeyFromPublicUrl(row.artwork_url); if (k){ const s = await signTracksKey(k); if (s) return s; }
      }
      if (row.cover_url && typeof row.cover_url === 'string') return row.cover_url;
      if (row.artwork_url && typeof row.artwork_url === 'string') return row.artwork_url;
      return null;
    }

    async function getSignedAudio(row){
      if (row.track_path && typeof row.track_path === 'string'){
        const s = await signTracksKey(row.track_path); if (s) return s;
      }
      if (row.audio_url && typeof row.audio_url === 'string'){
        const k = extractKeyFromPublicUrl(row.audio_url); if (k){ const s = await signTracksKey(k); if (s) return s; }
      }
      if (row.audio_url && typeof row.audio_url === 'string') return row.audio_url;
      return null;
    }

    const PLACEHOLDER_IMG = "data:image/svg+xml;utf8," + encodeURIComponent(
      `<svg xmlns='http://www.w3.org/2000/svg' width='120' height='120'>
        <defs><linearGradient id='g' x1='0' x2='1' y1='0' y2='1'>
          <stop offset='0%' stop-color='#2b3542'/><stop offset='100%' stop-color='#1a222c'/>
        </linearGradient></defs>
        <rect width='100%' height='100%' fill='url(#g)'/>
        <circle cx='60' cy='60' r='22' fill='#ff2b2b' opacity='.35'/>
      </svg>`
    );

    /* ---------- Left column: your uploads ---------- */
    async function loadMyTracks() {
      const list = document.getElementById("tracks-list");
      try {
        const { data: { user } } = await supabase.auth.getUser();
        if (!user) { list.innerHTML = `<div class="muted">Please sign in to see your uploads.</div>`; return; }

        const { data, error } = await supabase
          .from('tracks')
          .select('*')
          .eq('user_id', user.id)
          .order('created_at', { ascending: false })
          .limit(50);

        if (error) { list.innerHTML = `<div class="muted">Couldn't load tracks.</div>`; return; }
        if (!data || data.length === 0) { list.innerHTML = `<div class="muted">No uploads yet. Use “Submit Song”.</div>`; return; }

        list.innerHTML = '';
        for (const row of data) {
          const title  = row.title || row.name || (row.audio_filename ? row.audio_filename.replace(/\.[^/.]+$/,'') : 'Untitled track');
          const artist = row.artist || row.artist_name || '';
          const sub    = artist || row.genre || row.style || row.description || '';
          const signedCover = await getSignedCover(row);

          const div = document.createElement('div');
        div.className = 'upload-item';
          div.className += ' track-row';
          div.innerHTML = `
            <div class="cover"></div>
            <div class="track-main">
              <div class="track-title" title="${title}">${title}</div>
              <div class="track-sub" title="${sub}">${sub || '&nbsp;'}</div>
            <div class="manage"><div class="stats"><span class="ic">▶</span> ${row.plays ?? 0} • <span class="ic">♥</span> ${row.likes ?? 0}</div><div class="actions"><button class="mini danger" data-action="delete" data-id="${row.id}" data-audio="${row.track_path || ""}" data-cover="${row.cover_path || ""}">Delete</button><button class="mini" disabled title="Coming soon">Replace</button></div></div>
            </div>
          `;
          div.querySelector('.cover').style.backgroundImage = `url('${signedCover || PLACEHOLDER_IMG}')`;
          const del = div.querySelector('button[data-action="delete"]');
          if (del){
            del.addEventListener('click', async (ev) => {
              ev.stopPropagation();
              await deleteUpload(del.dataset.id, del.dataset.audio, del.dataset.cover, div);
            });
          }
          list.appendChild(div);
        }
      } catch {
        list.innerHTML = `<div class="muted">Unexpected error loading your tracks.</div>`;
      }
    }

    /* ---------- Playlist builder (single audio element with seek) ---------- */
    async function buildBasicPlaylist(rows){
      const items = [];
      for (const r of rows){
        const title  = r.title || r.name || (r.audio_filename ? r.audio_filename.replace(/\.[^/.]+$/,'') : 'Untitled');
        const artist = r.artist || r.artist_name || '';
        const coverKey = (r.cover_path && typeof r.cover_path === 'string') ? r.cover_path : extractKeyFromPublicUrl(r.cover_url || r.artwork_url || '');
        const coverUrl = coverKey ? await signTracksKey(coverKey) : (r.cover_url || r.artwork_url || null);
        const audioUrl = await getSignedAudio(r);
        if (!audioUrl) continue;
        items.push({ id: r.id, title, artist, cover: coverUrl, audio: audioUrl });
      }

      const listEl = document.getElementById('playlistList');
      const nowEl  = document.getElementById('nowPlaying');
      const audio  = document.getElementById('audio');
      const playBtn= document.getElementById('playPauseBtn');
        const consoleEl = document.querySelector('.player-console');
      const prevBtn= document.getElementById('prevBtn');
      const nextBtn= document.getElementById('nextBtn');
        const shuffleBtn = document.getElementById('shuffleBtn');
        const SHUFFLE_KEY = 'rr_shuffle_on';
        let shuffleOn = localStorage.getItem(SHUFFLE_KEY) === '1';
        if (shuffleBtn) shuffleBtn.classList.toggle('on', shuffleOn);
        let playOrder = [];
        let p = 0;

      const seek   = document.getElementById('seek');
      const curT   = document.getElementById('curTime');
      const durT   = document.getElementById('durTime');

      listEl.innerHTML = '';
      items.forEach((it, idx) => {
        const row = document.createElement('div');
        row.className = 'track-item';
        row.innerHTML = `
          <div class="thumb" style="background-image:url('${it.cover || ''}')"></div>
          <div class="meta">
            <div class="t" title="${it.title}">${it.title}</div>
            <div class="a" title="${it.artist}">${it.artist || '&nbsp;'}</div>
          </div>
        `;
        const eq = document.createElement('div');
        eq.className = 'eq-bars';
        eq.innerHTML = '<span></span><span></span><span></span>';
        row.querySelector('.meta').appendChild(eq);
        const rm = document.createElement('button');
        rm.className = 'pl-remove';
        rm.type = 'button';
        rm.title = 'Remove from playlist';
        rm.textContent = '×';
        row.appendChild(rm);
          rm.addEventListener('click', (ev) => {
            ev.stopPropagation();
            // find this row's current index (robust even after reorders)
            const index = [...listEl.children].indexOf(row);
            if (index === -1) return;

            const removedId = String(items[index].id);

            // Update localStorage playlist
            try {
              const arrRaw = getPL();
              const arr = Array.isArray(arrRaw) ? arrRaw.map(String).filter(Boolean) : [];
              const next = arr.filter(v => v !== removedId);
              localStorage.setItem(PL_KEY, JSON.stringify(next));
            } catch {}

            // Remove from in-memory list and UI
            const wasCurrent = (i === index);
            items.splice(index, 1);
            row.remove();
            if (i > index) i -= 1;

            if (!items.length) {
              pause();
              audio.src = '';
              nowEl.textContent = 'No playable tracks yet.';
              seek.value = 0; curT.textContent = '0:00'; durT.textContent = '0:00';
              if (typeof updatePlayingUI === 'function') updatePlayingUI();
              return;
            }

            if (shuffleOn) { if (i >= items.length) i = 0; buildOrder(i); }
            if (wasCurrent) {
              if (i >= items.length) i = 0;
              load(); play();
            } else {
              markActive();
              if (typeof updatePlayingUI === 'function') updatePlayingUI();
            }
          });
        row.addEventListener('click', () => startAt(idx));
        listEl.appendChild(row);
      });

      let i = 0;
        // Build a shuffled order that keeps the current index at the front
        function buildOrder(startIdx){
          const cur = Number.isInteger(startIdx) ? startIdx : 0;
          // make a list of indices
          let arr = items.map((_, idx) => idx);
          // remove current from array
          arr = arr.filter(x => x !== cur);
          // Fisher–Yates shuffle
          for (let j = arr.length - 1; j > 0; j--) {
            const k = Math.floor(Math.random() * (j + 1));
            [arr[j], arr[k]] = [arr[k], arr[j]];
          }
          // put current at the front
          playOrder = [cur, ...arr];
          p = 0;  // playOrder pointer
        }
        if (shuffleOn) { buildOrder(i); }
      function markActive(){
        [...listEl.children].forEach((el, idx) => el.classList.toggle('active', idx === i));
      }

        function updatePlayingUI(){
      [...listEl.children].forEach((el, idx) => el.classList.toggle("playing", idx === i && !audio.paused));
      if (consoleEl) { consoleEl.classList.toggle("playing", !audio.paused); }
    }

      function mmss(sec){
        if (!isFinite(sec)) return '0:00';
        sec = Math.max(0, Math.floor(sec));
        const m = Math.floor(sec / 60);
        const s = sec % 60;
        return m + ':' + String(s).padStart(2, '0');
      }

function reflectProgress(){
  const d = audio.duration || 0;
  const t = audio.currentTime || 0;

  if (isFinite(d) && d > 0) {
    seek.value = Math.round((t / d) * 1000);
    seek.style.setProperty('--val', (t / d * 100) + '%');
    durT.textContent = mmss(d);
  } else {
    seek.value = 0;
    seek.style.setProperty('--val', '0%');
    durT.textContent = '0:00';
  }

  curT.textContent = mmss(t);
}





      function load(){
        if (!items[i]) return;
        audio.src = items[i].audio;
        nowEl.textContent = `Now playing: ${items[i].title}${items[i].artist ? ' — ' + items[i].artist : ''}`;
        markActive();
      updatePlayingUI();
        // reset progress indicator
        seek.value = 0; curT.textContent = '0:00'; durT.textContent = '0:00';
      }

      function play(){ audio.play().catch(()=>{}); playBtn.textContent = '⏸ Pause'; updatePlayingUI(); }
      function pause(){ audio.pause(); playBtn.textContent = '▶ Play'; updatePlayingUI(); }
      function toggle(){ audio.paused ? play() : pause(); }
        function next(){
          if (shuffleOn && playOrder.length === items.length) {
            p = (p + 1) % playOrder.length;
            i = playOrder[p];
          } else {
            i = (i + 1) % items.length;
          }
          load(); play();
        }
        function prev(){
          if (shuffleOn && playOrder.length === items.length) {
            p = (p - 1 + playOrder.length) % playOrder.length;
            i = playOrder[p];
          } else {
            i = (i - 1 + items.length) % items.length;
          }
          load(); play();
        }
      function startAt(idx){ i = idx; if (shuffleOn) { buildOrder(i); } load(); play(); }

      audio.addEventListener('ended', next);
      audio.addEventListener('loadedmetadata', reflectProgress);
      audio.addEventListener('timeupdate', reflectProgress);
    audio.addEventListener('play', updatePlayingUI);
    audio.addEventListener('pause', updatePlayingUI);
    audio.addEventListener('ended', updatePlayingUI);
      playBtn.addEventListener('click', toggle);
      nextBtn.addEventListener('click', next);
        if (shuffleBtn) shuffleBtn.addEventListener('click', () => {
          shuffleOn = !shuffleOn;
          localStorage.setItem(SHUFFLE_KEY, shuffleOn ? '1' : '0');
          shuffleBtn.classList.toggle('on', shuffleOn);
          if (shuffleOn) { buildOrder(i); }
        });
      prevBtn.addEventListener('click', prev);

      // Seek
      seek.addEventListener('input', () => {
        const d = audio.duration || 0;
        if (isFinite(d) && d > 0) {
          const ratio = Number(seek.value) / 1000;
          audio.currentTime = d * ratio;
          reflectProgress();
        }
      });

      if (items.length){ load(); } else { nowEl.textContent = 'No playable tracks yet.'; }
    }

  async function deleteUpload(id, audioKey, coverKey, cardEl){
    try{
      if(!confirm("Delete this upload? This cannot be undone.")) return;
      const { data: { user } } = await supabase.auth.getUser();
      if(!user){ alert("Please sign in."); return; }
      // remove storage files if keys exist
      const keys = [audioKey, coverKey].filter(k => typeof k === 'string' && k.length);
      if (keys.length){ await supabase.storage.from('tracks').remove(keys); }
      // delete DB row (RLS must allow owner)
      const { error } = await supabase.from('tracks').delete().eq('id', id);
      if (error){ console.error(error); alert('Delete failed.'); return; }
      if (cardEl) cardEl.remove();
    } catch(err){ console.error(err); alert('Delete error.'); }
  }
    /* ---------- Shared local playlist helpers ---------- */
    const PL_KEY = "rr_playlist_ids";
      const ALLOW_UPLOAD_FALLBACK = false;
    const getPL = () => {
      try { return JSON.parse(localStorage.getItem(PL_KEY) || "[]"); }
      catch { return []; }
    };

    /* ---------- Dashboard init ---------- */
    async function initDashboard(){
      await loadMyTracks();

      // Prefer Library’s selected playlist (any owner; RLS still applies)
      const plIdsRaw = getPL();
      const plIds = Array.isArray(plIdsRaw) ? plIdsRaw.map(String).filter(Boolean) : [];
      let rows = [];

      if (plIds.length){
        const { data: byIds, error: byIdsErr } = await supabase
          .from('tracks')
          .select('*')
          .in('id', plIds)
          .order('created_at', { ascending: false })
          .limit(100);

        if (!byIdsErr && Array.isArray(byIds)) {
          // Keep playlist order as saved in Library if possible
          const map = new Map(byIds.map(r => [String(r.id), r]));
          rows = plIds.map(id => map.get(String(id))).filter(Boolean);
        }
      }

      // Fallback to the user’s own uploads if no playlist
        if (ALLOW_UPLOAD_FALLBACK && !rows.length){
        const { data: { user } } = await supabase.auth.getUser();
        if (!user) {
          document.getElementById('nowPlaying').textContent = 'Sign in to see your uploads or add tracks from the Library.';
          return;
        }
        const { data, error } = await supabase
          .from('tracks')
          .select('*')
          .eq('user_id', user.id)
          .order('created_at', { ascending: false })
          .limit(50);

        if (error || !data) {
          document.getElementById('nowPlaying').textContent = 'Could not load tracks.';
          return;
        }
        rows = data;
      }

      if (rows && rows.length) { await buildBasicPlaylist(rows); }
      else { document.getElementById('nowPlaying').textContent = 'No playable tracks yet.'; }
    }

    // Ensure init runs whether DOM is already loaded or not
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initDashboard);
    } else {
      initDashboard();
    }

    /* --- logout (safety) --- */
    async function logout(){ await supabase.auth.signOut(); window.location.href="/login.html"; }



// Welcome text from Auth metadata display_name
(async () => {
  const { data: { user } } = await supabase.auth.getUser();
  const el = document.getElementById('welcomeUser');
  if (!el) return;
  const name = user?.user_metadata?.display_name
            || (user?.email ? user.email.split('@')[0] : null)
            || 'User';
  el.textContent = `Welcome, ${name}`;
})();


  </script>
<script>/* Volume wiring (FIXES 7) */(function(){
  var a=document.getElementById("audio");
  var v=document.getElementById("volume");
  if(!a||!v) return;
  try{ v.value=(typeof a.volume==="number")?a.volume:1; }catch(e){}
  v.addEventListener("input",function(){
    var x=parseFloat(v.value); if(isNaN(x)) x=1; x=Math.min(1,Math.max(0,x));
    try{ a.volume=x; }catch(e){}
  });
})();</script>
<script>/* KB v2 (FIXES 7) */(function(){
  var a=document.getElementById("audio"); if(!a) return;
  function isTyping(el){ if(!el) return false; var t=el.tagName; var ty=el.type||""; return t==="INPUT"||t==="TEXTAREA"||el.isContentEditable||ty==="range"; }
  function clamp(x,min,max){ return Math.max(min, Math.min(max, x)); }
  document.addEventListener("keydown", function(e){
    if(isTyping(document.activeElement)) return;
    var k=e.key||"";
    if(k===" "){ e.preventDefault(); var b=document.getElementById("playPauseBtn"); if(b){ b.click(); } else { try{ a.paused?a.play():a.pause(); }catch(_){ } } }
    else if(k==="ArrowLeft"){ e.preventDefault(); try{ a.currentTime = clamp((a.currentTime||0)-5, 0, a.duration||1e9); }catch(_){ } }
    else if(k==="ArrowRight"){ e.preventDefault(); try{ a.currentTime = clamp((a.currentTime||0)+5, 0, a.duration||1e9); }catch(_){ } }
    else if(k==="ArrowUp"){ e.preventDefault(); try{ a.volume = clamp((a.volume||0)+0.05, 0, 1); var v=document.getElementById("volume"); if(v) v.value=a.volume; }catch(_){ } }
    else if(k==="ArrowDown"){ e.preventDefault(); try{ a.volume = clamp((a.volume||0)-0.05, 0, 1); var v2=document.getElementById("volume"); if(v2) v2.value=a.volume; }catch(_){ } }
    else if(k==="s" || k==="S"){ var s=document.getElementById("shuffleBtn"); if(s){ e.preventDefault(); s.click(); } }
  }, true);
})();</script>
<script>/* New Track Toast polling (FIXES 7) */(function(){
  var toast=document.getElementById("newTrackToast");
  if(!toast) return;
  var msg=toast.querySelector(".msg");
  var dismiss=toast.querySelector(".dismiss");
  function show(text){ if(msg){ msg.textContent=text; } toast.style.display="flex"; toast.classList.add("show"); }
  function hide(){ toast.classList.remove("show"); toast.style.display="none"; }
  if(dismiss){ dismiss.addEventListener("click", function(e){ e.stopPropagation(); hide(); }); }
  toast.addEventListener("click", function(){ try{ window.location.href="/library.html"; }catch(_){ } });

  // Try to find an existing Supabase client used by this page
  var sb = (typeof supabase !== "undefined") ? supabase : null;
  // If not found, try a very naive fallback (some pages attach it on window.supabase)
  if(!sb && window.supabase && typeof window.supabase.from === "function"){ sb = window.supabase; }
  if(!sb || typeof sb.from !== "function"){ return; }

  // Mark the time we loaded so we only alert for truly NEW tracks
  var lastSeen = Date.now();
  async function check(){
    try {
      var q = sb.from("tracks").select("id,title,artist,created_at,status").eq("status","public").order("created_at",{ascending:false}).limit(1);
      var res = await q;
      var row = (res && res.data && res.data[0]) ? res.data[0] : null;
      if(!row || !row.created_at) return;
      var ts = Date.parse(row.created_at)||0;
      if(ts > lastSeen + 1000){
        var who = row.artist || "Unknown";
        var title = row.title || "Untitled";
        show("New track from " + who + ": " + title);
        // Advance the watermark so we dont spam
        lastSeen = ts;
      }
    } catch(e) { /* silent */ }
  }
  // Run every 30s
  setInterval(check, 30000);
})();</script>
<script>/* Toast test hook (FIXES 7) */(function(){
  window._toastTest = function(msg){
    var t=document.getElementById("newTrackToast"); if(!t) return;
    var m=t.querySelector(".msg"); if(m) m.textContent = msg || "New track uploaded";
    t.style.display = "flex"; t.classList.add("show");
  };
})();</script>
<style id="uploads-ui-css">


  /* Preview-only: hide original per-card action row but keep DOM for handlers */
  .upload-item.track-row div.actions { display: none !important; }

  /* 3-dot menu styles */
  .kebab{position:relative;display:inline-flex;align-items:center;justify-content:center;width:36px;height:36px;border:1px solid rgba(255,42,42,.35);border-radius:9px;background:rgba(15,15,18,.6);cursor:pointer}
  .kebab .dots{width:4px;height:4px;border-radius:999px;background:#fff;box-shadow:0 -8px 0 #fff,0 8px 0 #fff}
  .kebab-slot{position:relative;margin-left:auto;display:inline-flex;align-items:center}
  .kebab-menu{position:absolute;right:0;top:40px;min-width:160px;background:rgba(12,12,14,.96);border:1px solid rgba(255,42,42,.35);border-radius:12px;padding:6px;display:none;z-index:50}
  .kebab-menu.open{display:block}
  .kebab-menu button{width:100%;text-align:left;padding:10px 12px;border:0;background:transparent;color:#fff;border-radius:8px}
  .kebab-menu button:hover{background:rgba(255,42,42,.12)}
  /* Counts alignment: keep icon+number together, add gap between pairs */
  .upload-item.track-row .stats{
    display: inline-flex;
    align-items: center;
    gap: 14px;           /* space between play and like groups */
    margin-top: 2px;
  }
  .upload-item.track-row .stats .ic{
    display: inline-flex;
    align-items: center;
    gap: 6px;            /* space between icon and number */
  }

</style>
<script>
(function() {
  console.log('uploads-ui: preview enhancer WITH wrap+counts');

  function findBtnByText(root, text) {
    const t = String(text).trim().toLowerCase();
    return [...root.querySelectorAll('button, a')].find(el => el.textContent.trim().toLowerCase() === t) || null;
  }

  function groupCounts(stats) {
    if (!stats) return;
    // Build groups: [icon + number], [icon + number]; drop stray bullets
    const kids = [...stats.childNodes].filter(n => n.nodeType === 1 || (n.nodeType === 3 && n.textContent.trim()));
    if (!kids.length) return;

    const clean = s => (s || '').replace(/[•\.\s]+/g, ' ').trim();
    const groups = [];
    for (let i = 0; i < kids.length; i++) {
      const n = kids[i];
      if (n.nodeType === 1 && /\bic\b/.test(n.className)) {
        let numText = '';
        for (let j = i + 1; j < kids.length; j++) {
          const m = kids[j];
          if (m.nodeType === 3) {
            const t = clean(m.textContent);
            if (t && t !== '•') { numText = t; i = j; break; }
          } else if (m.nodeType === 1 && /\bic\b/.test(m.className)) {
            break;
          }
        }
        const g = document.createElement('span');
        g.className = 'ic';
        g.appendChild(n.cloneNode(true));
        if (numText) g.appendChild(document.createTextNode(' ' + numText));
        groups.push(g);
      }
    }
    if (groups.length) {
      stats.textContent = '';
      groups.forEach(g => stats.appendChild(g));
    }
  }

  function wrapTextStack(card) {
    const main = card.querySelector('.track-main') || card;
    let stack = main.querySelector('.text-stack');
    if (!stack) {
      stack = document.createElement('div');
      stack.className = 'text-stack';
      const cover = main.querySelector('.cover');
      if (cover && cover.nextSibling) main.insertBefore(stack, cover.nextSibling);
      else main.prepend(stack);
    }
    const title  = main.querySelector('.track-title');
    const artist = main.querySelector('.track-sub');
    const stats  = card.querySelector('.stats');

    [title, artist, stats].forEach(n => { if (n && n.parentElement !== stack) stack.appendChild(n); });
    groupCounts(stats);
  }

  function addKebab(card) {
    if (card.querySelector('.kebab-slot')) return;

    const main = card.querySelector('.track-main') || card;
    if (getComputedStyle(main).display === 'inline') main.style.display = 'flex';
    main.style.alignItems = main.style.alignItems || 'center';

    const slot = document.createElement('div');
    slot.className = 'kebab-slot';

    const kebab = document.createElement('button');
    kebab.className = 'kebab'; kebab.type = 'button';
    kebab.setAttribute('aria-label','Open actions');
    kebab.innerHTML = '<span class="dots" aria-hidden="true"></span>';

    const menu = document.createElement('div');
    menu.className = 'kebab-menu';
    menu.innerHTML = `
      <button data-action="edit">Edit</button>
      <button data-action="move-up">Move up</button>
      <button data-action="move-down">Move down</button>
      <button data-action="delete">Delete</button>
    `;

    slot.appendChild(kebab);
    slot.appendChild(menu);
    main.appendChild(slot);

    const actions = card.querySelector('div.actions');
    const delBtn = actions ? findBtnByText(actions, 'Delete') : null;
    const repBtn = actions ? findBtnByText(actions, 'Replace') : null;

    kebab.addEventListener('click', (e) => {
      e.stopPropagation();
      const open = menu.classList.toggle('open');
      if (open) {
        const close = () => { menu.classList.remove('open'); document.removeEventListener('click', close); };
        document.addEventListener('click', close);
      }
    });

    menu.addEventListener('click', (e) => {
      const btn = e.target.closest('button[data-action]');
      if (!btn) return;
      const action = btn.dataset.action;
      switch (action) {
        case 'edit':     if (repBtn) repBtn.click(); break;
        case 'move-up':  if (card.previousElementSibling) card.parentElement.insertBefore(card, card.previousElementSibling); break;
        case 'move-down':if (card.nextElementSibling)     card.parentElement.insertBefore(card.nextElementSibling, card);  break;
        case 'delete':   if (delBtn) delBtn.click(); break;
      }
      menu.classList.remove('open');
    });
  }

  function enhanceCard(card) {
    if (!card || card.dataset.kebabReady === '1') return;
    wrapTextStack(card);
    addKebab(card);
    card.dataset.kebabReady = '1';
  }

  function enhanceExisting() {
    const cards = document.querySelectorAll('.upload-item.track-row');
    console.log('uploads-ui: scan ->', cards.length);
    cards.forEach(enhanceCard);
  }

  // Initial scan + MutationObserver for dynamic loads
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', enhanceExisting);
  else enhanceExisting();

  const obs = new MutationObserver((list) => {
    for (const m of list) {
      if (m.type === 'childList') {
        m.addedNodes.forEach(node => {
          if (!(node instanceof Element)) return;
          if (node.matches && node.matches('.upload-item.track-row')) enhanceCard(node);
          node.querySelectorAll && node.querySelectorAll('.upload-item.track-row').forEach(enhanceCard);
        });
      }
    }
  });
  const target = document.querySelector('.uploads-scroll') || document.querySelector('.your-uploads') || document.body;
  obs.observe(target, { childList: true, subtree: true });
  console.log('uploads-ui: observer on', target.className || target.tagName);
})();
</script>




<style id="uploads-ui-slim">
  /* Slim row layout for preview only */
  .upload-item.track-row .track-main{
    display: grid !important;
    grid-template-columns: 56px 1fr auto; /* cover | text | kebab */
    column-gap: 14px;
    align-items: center;
    min-height: 84px;
    padding: 12px 14px;
  }

  /* Artwork */
  .upload-item.track-row .cover{
    width: 56px; height: 56px;
    border-radius: 8px; overflow: hidden;
  }
  .upload-item.track-row .cover img{
    width: 100%; height: 100%; object-fit: cover;
    display: block;
  }

  /* Text stack */
  .upload-item.track-row .text-stack{
    display: grid;
    grid-template-rows: auto auto auto; /* title, artist, counts */
    row-gap: 4px;
  }
  /* Map existing nodes into the stack */
  .upload-item.track-row .track-title{ font-weight: 700; line-height: 1.15; }
  .upload-item.track-row .track-sub{ opacity: .9; font-size: .95rem; }

  /* Counts directly under artist */
  .upload-item.track-row .stats{
    margin-top: 2px;
    display: inline-flex; gap: 12px; align-items: center;
    font-size: .95rem;
  }
  .upload-item.track-row .stats .ic{ display: inline-flex; gap: 6px; align-items: center; }

  /* Kebab on the right */
  .upload-item.track-row .kebab-slot{ margin-left: 0; justify-self: end; }
</style>
<style id="uploads-ui-tweaks">
  /* 1) Less vertical padding on the card row */
  .upload-item.track-row .track-main{
    min-height: 68px !important;
    padding: 8px 10px !important;
    align-items: start !important;   /* content aligns to top */
  }

  /* 2) Artwork closer to the top */
  .upload-item.track-row .cover{
    width: 52px; height: 52px;       /* slightly smaller for tighter row */
    align-self: start;               /* pin to top of grid cell */
  }

  /* 3) Prevent title/artist from clipping (ellipsis instead) */
  .upload-item.track-row .track-title,
  .upload-item.track-row .track-sub{
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 100%;
    line-height: 1.15;
    margin: 0;                       /* no extra top/bottom */
  }

  /* 4) Smaller 3-dot button */
  .upload-item.track-row .kebab{ width: 30px; height: 30px; border-radius: 8px; }
  .upload-item.track-row .kebab-slot{ align-self: start; }  /* top-align the button */

  /* 5) Opaque menu (no see-through) */
  .upload-item.track-row .kebab-menu{
    background: rgba(12,12,14,1) !important; /* fully opaque */
    backdrop-filter: none !important;
    box-shadow: 0 12px 28px rgba(0,0,0,.55);
    border-color: rgba(255,42,42,.35);
  }

  /* keep counts tidy */
  .upload-item.track-row .stats{ display:inline-flex; gap:14px; align-items:center; margin-top:2px; }
  .upload-item.track-row .stats .ic{ display:inline-flex; gap:6px; align-items:center; }
  /* Keep kebab menu solid even on hover */
  .upload-item.track-row .kebab-menu,
  .upload-item.track-row .kebab-menu:hover,
  .upload-item.track-row .kebab-menu:focus {
    background: #0a0a0c !important;
    opacity: 1 !important;
    backdrop-filter: none !important;
  }


</style>
<style id="uploads-ui-tweaks-2">

  /* Fix bottom padding */
  .upload-item.track-row .track-main{
    padding-top: 8px !important;
    padding-bottom: 4px !important; /* tighter bottom */
  }

  /* Smaller text instead of ellipsis */
  .upload-item.track-row .track-title{
    font-size: 0.95rem;   /* adjust down slightly */
    white-space: normal;  /* allow wrapping */
    overflow: visible;
    text-overflow: unset;
  }
  .upload-item.track-row .track-sub{
    font-size: 0.85rem;
    white-space: normal;
    overflow: visible;
    text-overflow: unset;
  }

  /* Fully solid menu background */
  .upload-item.track-row .kebab-menu{
    background: #0a0a0c !important;  /* solid dark */
    opacity: 1 !important;
  }
/* Force solid menu even on hover/focus/active */
.upload-item.track-row .kebab-slot .kebab-menu,
.upload-item.track-row .kebab-slot .kebab-menu:hover,
.upload-item.track-row .kebab-slot .kebab-menu:focus,
.upload-item.track-row .kebab-slot .kebab-menu:active {
  background: #0a0a0c !important;
  opacity: 1 !important;
  backdrop-filter: none !important;
  filter: none !important;
  transition: none !important;
  box-shadow: 0 12px 28px rgba(0,0,0,.55) !important;
  z-index: 9999 !important;
}
/* Force kebab menu solid, even on hover/focus/active */
.upload-item.track-row .kebab-slot .kebab-menu,
.upload-item.track-row .kebab-slot .kebab-menu:hover,
.upload-item.track-row .kebab-slot .kebab-menu:focus,
.upload-item.track-row .kebab-slot .kebab-menu:active {
  background: #0a0a0c !important;   /* solid dark */
  opacity: 1 !important;
  filter: none !important;
  backdrop-filter: none !important;
  mix-blend-mode: normal !important;
  transition: none !important;
}
/* STOP hover transparency: remove overlays & blending */
.upload-item.track-row .kebab-menu{
  background: #0a0a0c !important;   /* solid */
  opacity: 1 !important;
  filter: none !important;
  backdrop-filter: none !important;
  mix-blend-mode: normal !important;
  isolation: isolate !important;     /* prevent ancestor blending */
}

/* nuke any pseudo-element layers */
.upload-item.track-row .kebab-menu::before,
.upload-item.track-row .kebab-menu::after,
.upload-item.track-row .kebab-menu:hover::before,
.upload-item.track-row .kebab-menu:hover::after {
  content: none !important;
  display: none !important;
  background: transparent !important;
  opacity: 0 !important;
}

</style>
<style id="force-solid-kebab">
/* FINAL override for kebab menu transparency */
.upload-item.track-row .kebab-menu,
.upload-item.track-row .kebab-menu:hover,
.upload-item.track-row .kebab-menu:focus,
.upload-item.track-row .kebab-menu:active {
  background: #0a0a0c !important;   /* solid dark */
  opacity: 1 !important;
  filter: none !important;
  backdrop-filter: none !important;
  mix-blend-mode: normal !important;
}
</style>
<!-- FINAL overrides for kebab menu: solid + portal + edit fix -->




<script>
/* Portal the kebab menu to <body> (solid) + fix Edit action */
(function(){
  function getCard(el){ return el.closest('.upload-item.track-row'); }

  // Open/close with portal so parent hovers can't affect background
  function attachPortal(){
    document.querySelectorAll('.kebab').forEach(kebab => {
      // avoid double-binding
      if (kebab.dataset.portalReady === '1') return;
      kebab.dataset.portalReady = '1';

      kebab.addEventListener('click', (ev) => {
        ev.preventDefault(); ev.stopPropagation(); ev.stopImmediatePropagation();

        const slot = kebab.parentElement;               // .kebab-slot
        const menu = slot && slot.querySelector('.kebab-menu');
        if (!menu) return;

        // toggle close if already open
        if (menu.classList.contains('portaled')) { return closeMenu(menu, slot); }

        // open: move to body and position under kebab
        const r = kebab.getBoundingClientRect();
        menu.classList.add('portaled');
        document.body.appendChild(menu);
        menu.style.left = Math.round(r.left) + 'px';
        menu.style.top  = Math.round(r.bottom + 6) + 'px';

        // outside click closes
        const onDoc = (e) => { if (!menu.contains(e.target)) closeMenu(menu, slot); };
        setTimeout(() => document.addEventListener('click', onDoc, { once: true }), 0);
      }, true);
    });
  }

  function closeMenu(menu, slot){
    if (slot && slot.isConnected) slot.appendChild(menu);
    menu.classList.remove('portaled');
    menu.removeAttribute('style');
  }

  // Make "Edit" reliably trigger Replace / file chooser
  function attachEditFix(){
    if (window._kebabEditPatched) return; window._kebabEditPatched = true;

    document.addEventListener('click', (e) => {
      const item = e.target.closest('.kebab-menu button[data-action="edit"]');
      if (!item) return;

      const card = getCard(item);
      if (!card) return;

      // 1) Prefer file input in this card
      const fileInput =
        card.querySelector('input[type="file"]:not([disabled])') ||
        card.querySelector('.actions input[type="file"]') ||
        card.querySelector('label[for] + input[type="file"]');
      if (fileInput) { fileInput.click(); return; }

      // 2) Fallback: Replace button by text
      const repBtn = [...card.querySelectorAll('button,a')]
        .find(el => el.textContent.trim().toLowerCase() === 'replace');
      if (repBtn) { repBtn.click(); return; }

      // 3) Last resort: any element with replace-ish class/id/name
      const hint = card.querySelector('[class*="replace"],[id*="replace"],[name*="replace"]');
      if (hint) hint.click();
    }, true);
  }

  function init(){
    attachPortal();
    attachEditFix();
  }

  // Run now and also when dynamic cards appear
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', init);
  else init();

  const obs = new MutationObserver(() => attachPortal());
  obs.observe(document.body, { childList: true, subtree: true });
})();
</script>
<!-- Kebab menu: solid + portal + close rules + keep-open on move -->
<style id="kebab-portal-css">
  .kebab-menu.portaled{
    position:fixed!important;
    background:#0a0a0c!important; opacity:1!important;
    filter:none!important; backdrop-filter:none!important; mix-blend-mode:normal!important;
    z-index:99999!important; transition:none!important;

    display:inline-block!important; width:auto!important; min-width:180px!important; max-width:280px!important;
    box-sizing:border-box!important;
    border:1px solid rgba(255,42,42,.35)!important; border-radius:12px!important;
    box-shadow:0 12px 28px rgba(0,0,0,.55)!important;
  }
  .kebab-menu.portaled button{ white-space:nowrap!important; }
</style>

<script>
(function(){
  // Reset kebab buttons to remove any stale listeners
  document.querySelectorAll('.kebab').forEach(btn => {
    if (btn.dataset._rebuilt === '1') return;
    const clone = btn.cloneNode(true);
    clone.className = btn.className;
    btn.parentNode.replaceChild(clone, btn);
  });

  let current = null, currentSlot = null, currentKebab = null;

  function positionMenuNearKebab(menu, kebab){
    const r = kebab.getBoundingClientRect();
    const left = Math.min(Math.max(8, r.left), window.innerWidth - 300);
    menu.style.left = Math.round(left) + 'px';
    menu.style.top  = Math.round(r.bottom + 6) + 'px';
  }

  function closeMenu(){
    if (!current) return;
    if (currentSlot && currentSlot.isConnected) currentSlot.appendChild(current);
    current.classList.remove('portaled');
    current.removeAttribute('style');
    current = currentSlot = currentKebab = null;
  }
  window._kebabForceClose = closeMenu;

  // Bind open/close once
  document.querySelectorAll('.kebab').forEach(kebab => {
    if (kebab.dataset._bound === '1') return;
    kebab.dataset._bound = '1';

    kebab.addEventListener('click', (e) => {
      e.preventDefault(); e.stopPropagation();

      const slot = kebab.parentElement;
      const menu = slot && slot.querySelector('.kebab-menu');
      if (!menu) return;

      // Toggle if same menu is open
      if (current === menu) { closeMenu(); return; }

      // Close previous and open this one
      closeMenu();
      current = menu; currentSlot = slot; currentKebab = kebab;
      menu.classList.add('portaled');
      document.body.appendChild(menu);
      positionMenuNearKebab(menu, kebab);

      // Close on outside click / scroll / resize / ESC
      const outside = (ev) => {
        if (!menu.contains(ev.target) && !kebab.contains(ev.target)) {
          document.removeEventListener('pointerdown', outside, true);
          closeMenu();
        }
      };
      setTimeout(() => document.addEventListener('pointerdown', outside, true), 0);

      const onScroll = () => { window.removeEventListener('scroll', onScroll, {passive:true}); closeMenu(); };
      const onResize = () => { window.removeEventListener('resize', onResize); closeMenu(); };
      const onKey = (ev) => { if (ev.key === 'Escape') { document.removeEventListener('keydown', onKey); closeMenu(); } };
      window.addEventListener('scroll', onScroll, { passive:true, once:true });
      window.addEventListener('resize', onResize, { once:true });
      document.addEventListener('keydown', onKey);

      // Keep open for move actions; close for delete
      // Item clicks: keep open for move up/down; close for everything else (incl. blank clicks)
      menu.addEventListener('click', function onClick(ev){
        const btn  = ev.target.closest('button[data-action]');
        const card = kebab.closest('.upload-item.track-row');

        // Clicked blank area inside the menu => close
        if (!btn) { ev.stopPropagation(); closeMenu(); return; }

        if (!card) { closeMenu(); return; }

        const action = btn.dataset.action;

        if (action === 'move-up') {
          if (card.previousElementSibling) card.parentElement.insertBefore(card, card.previousElementSibling);
          positionMenuNearKebab(menu, kebab);
          ev.stopPropagation();
          return; // keep open so you can keep moving
        }

        if (action === 'move-down') {
          if (card.nextElementSibling) card.parentElement.insertBefore(card.nextElementSibling, card);
          positionMenuNearKebab(menu, kebab);
          ev.stopPropagation();
          return; // keep open so you can keep moving
        }

        if (action === 'delete') {
          const delBtn = [...card.querySelectorAll('button,a')]
            .find(x => x.textContent.trim().toLowerCase() === 'delete');
          if (delBtn) delBtn.click();
          closeMenu(); // close after delete
          return;
        }

        // Any other action (e.g., Edit not wired yet) => close the menu
        ev.stopPropagation();
        closeMenu();
      }, { once:false });


    });
  });
})();
</script>
<script>
/* Force-close kebab menu on any menu click except move-up/down (capture phase) */
(function(){
  document.addEventListener('click', function(e){
    const menu = e.target.closest('.kebab-menu.portaled');
    if (!menu) return;                         // not a menu click
    const btn = e.target.closest('button[data-action]');
    const action = btn && btn.dataset.action;

    // Keep open only for move actions
    if (action === 'move-up' || action === 'move-down') return;

    // For delete, edit, or blank area inside menu -> close
    if (window._kebabForceClose) window._kebabForceClose();
  }, true); // capture so it wins over any bubbling handlers
})();
</script>
<script>
/* Close kebab menu on any menu click except move-up/down.
   Also remember the slot when opening, so we can return the menu correctly. */
(function(){
  // Rebind kebab open to store slot on the menu
  document.querySelectorAll('.kebab').forEach(kebab => {
    if (kebab.dataset._slotMem === '1') return;
    kebab.dataset._slotMem = '1';
    kebab.addEventListener('click', (e) => {
      // find this kebab's menu (already opened by existing handler)
      const slot = kebab.parentElement;                         // .kebab-slot
      const menu = document.querySelector('.kebab-menu.portaled');
      if (!menu) return;
      // remember where to return it
      menu._slot = slot;
    }, true); // capture so it runs even if other handlers stop propagation
  });

  // Capture clicks inside an open menu
  document.addEventListener('click', (e) => {
    const menu = e.target.closest('.kebab-menu.portaled');
    if (!menu) return; // not a click inside an open menu

    const btn = e.target.closest('button[data-action]');
    const action = btn && btn.dataset.action;

    // Keep open only for move actions
    if (action === 'move-up' || action === 'move-down') return;

    // Otherwise: close and return to original slot
    const slot = menu._slot;
    if (slot && slot.isConnected) slot.appendChild(menu);
    menu.classList.remove('portaled');
    menu.removeAttribute('style');
  }, true); // capture so it wins over bubbling handlers
})();
</script>
<script>
/* Re-arm closers after each Move Up/Down click */
(function(){
  function armClosersOnce(){
    const close = () => { window._kebabForceClose && window._kebabForceClose(); };
    const onPointer = (e) => {
      // ignore clicks inside an open menu or on a kebab button
      if (e.target.closest('.kebab-menu.portaled') || e.target.closest('.kebab')) return;
      document.removeEventListener('pointerdown', onPointer, true);
      close();
    };
    const onEsc = (e) => { if (e.key === 'Escape') { document.removeEventListener('keydown', onEsc); close(); } };
    const onScroll = () => { window.removeEventListener('scroll', onScroll, {passive:true}); close(); };
    const onResize = () => { window.removeEventListener('resize', onResize); close(); };

    setTimeout(() => document.addEventListener('pointerdown', onPointer, true), 0);
    document.addEventListener('keydown', onEsc, { once:true });
    window.addEventListener('scroll', onScroll, { passive:true, once:true });
    window.addEventListener('resize', onResize, { once:true });
  }

  // When a move-up/down button inside an open menu is clicked, re-arm closers
  document.addEventListener('click', function(e){
    const btn = e.target.closest('.kebab-menu.portaled button[data-action]');
    if (!btn) return;
    const a = btn.dataset.action;
    if (a === 'move-up' || a === 'move-down') {
      // give the DOM a tick to move the card, then arm the closers
      setTimeout(armClosersOnce, 0);
    }
  }, true);
})();
</script>
<script>
/* After Move up/down, allow outside click / ESC / scroll to close the menu */
(function(){
  // Mark when a move action was used
  document.addEventListener('click', function(e){
    const btn = e.target.closest('.kebab-menu.portaled button[data-action]');
    if (!btn) return;
    const a = (btn.dataset.action || '').toLowerCase();
    if (a === 'move-up' || a === 'move-down') {
      window._kebabMoved = true;
      // ensure the menu remembers its slot for closing
      const menu = document.querySelector('.kebab-menu.portaled');
      if (menu && !menu._slot) {
        const k = document.querySelector('.kebab .kebab').closest('.kebab-slot'); // fallback no-op
      }
    }
  }, true);

  function getOpenMenu(){ return document.querySelector('.kebab-menu.portaled'); }

  function forceClose(){
    const menu = getOpenMenu();
    if (!menu) { window._kebabMoved = false; return; }
    const slot = menu._slot || menu.__slot || menu.dataset.slotEl && document.querySelector(menu.dataset.slotEl);
    if (slot && slot.isConnected) slot.appendChild(menu);
    menu.classList.remove('portaled');
    menu.removeAttribute('style');
    window._kebabMoved = false;
  }
  // Override any previous close function
  window._kebabForceClose = forceClose;

  // Outside click closes (only after a move)
  document.addEventListener('pointerdown', function(e){
    if (!window._kebabMoved) return;
    const menu = getOpenMenu();
    if (!menu) { window._kebabMoved = false; return; }
    if (menu.contains(e.target) || e.target.closest('.kebab')) return;
    forceClose();
  }, true);

  // ESC closes (only after a move)
  window.addEventListener('keydown', function(e){
    if (!window._kebabMoved) return;
    if (e.key === 'Escape') forceClose();
  });

  // Scroll/resize closes (only after a move)
  window.addEventListener('scroll', function(){ if (window._kebabMoved) forceClose(); }, { passive: true });
  window.addEventListener('resize', function(){ if (window._kebabMoved) forceClose(); });
})();
</script>
<script>
/* Kebab finalizer: unify state so menus always re-open on the same track */
(function(){
  // Global state
  const S = (window.__kebabState ||= { menu:null, slot:null, kebab:null });

  // Canonical close
  function closeNow(){
    if (!S.menu) return;
    if (S.slot && S.slot.isConnected) S.slot.appendChild(S.menu);
    S.menu.classList.remove('portaled');
    S.menu.removeAttribute('style');
    S.menu = S.slot = S.kebab = null;
    window._kebabMoved = false;
  }
  // Expose as the only close
  window._kebabForceClose = closeNow;

  // Position helper
  function place(menu, kebab){
    const r = kebab.getBoundingClientRect();
    const left = Math.min(Math.max(8, r.left), window.innerWidth - 300);
    menu.style.left = Math.round(left) + 'px';
    menu.style.top  = Math.round(r.bottom + 6) + 'px';
  }

  // Intercept kebab clicks in capture to beat older handlers
  document.addEventListener('click', (ev) => {
    const kb = ev.target.closest('.kebab');
    if (!kb) return;

    // prevent older handlers from running
    ev.preventDefault(); ev.stopPropagation();

    const slot = kb.parentElement;
    const menu = slot && slot.querySelector('.kebab-menu');
    if (!menu) return;

    // If this same menu is tracked as "open" but it's not actually portaled, treat as closed
    const isActuallyOpen = menu.classList.contains('portaled');

    if (S.menu && S.menu !== menu) closeNow();            // different menu was tracked -> close it
    if (S.menu === menu && isActuallyOpen) {               // toggle: currently open -> close
      closeNow();
      return;
    }

    // Open this menu afresh
    S.menu = menu; S.slot = slot; S.kebab = kb;
    menu.classList.add('portaled');
    document.body.appendChild(menu);
    place(menu, kb);
    window._kebabMoved = false; // clear any move flag on new open

    // Outside click / ESC / scroll close (re-armed each open)
    const outside = (e) => { if (!menu.contains(e.target) && !kb.contains(e.target)) { document.removeEventListener('pointerdown', outside, true); closeNow(); } };
    setTimeout(() => document.addEventListener('pointerdown', outside, true), 0);
    const onEsc = (e) => { if (e.key === 'Escape') { document.removeEventListener('keydown', onEsc); closeNow(); } };
    document.addEventListener('keydown', onEsc, { once:true });
    window.addEventListener('scroll', () => closeNow(), { once:true, passive:true });
    window.addEventListener('resize', () => closeNow(), { once:true });

    // Keep open for move up/down; close for others (but don’t double-bind)
    if (!menu.dataset._finalBound) {
      menu.dataset._finalBound = '1';
      menu.addEventListener('click', (e) => {
        const btn = e.target.closest('button[data-action]');
        // blank area inside menu closes
        if (!btn) { closeNow(); return; }
        const a = btn.dataset.action;
        const card = kb.closest('.upload-item.track-row');
        if (!card) { closeNow(); return; }

        if (a === 'move-up') {
          if (card.previousElementSibling) card.parentElement.insertBefore(card, card.previousElementSibling);
          place(menu, kb);
          window._kebabMoved = true;
          e.stopPropagation();
          return; // keep open
        }
        if (a === 'move-down') {
          if (card.nextElementSibling) card.parentElement.insertBefore(card.nextElementSibling, card);
          place(menu, kb);
          window._kebabMoved = true;
          e.stopPropagation();
          return; // keep open
        }
        if (a === 'delete') {
          const delBtn = [...card.querySelectorAll('button,a')].find(x => x.textContent.trim().toLowerCase() === 'delete');
          if (delBtn) delBtn.click();
          closeNow(); // close after delete
          return;
        }
        // Any other action -> close
        closeNow();
      });
    }
  }, true); // capture
})();
</script>



</body>
</html>

